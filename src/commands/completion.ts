/**
 * Shell Completion Script Generator
 *
 * Generates shell completion scripts for bash, zsh, and fish shells.
 * Scripts are generated statically from the command registry to avoid
 * runtime overhead during tab completion.
 */

/* eslint-disable no-useless-escape */
// Note: The \$ escapes in template literals below are intentional - they produce
// literal $ characters in the generated shell scripts.

import chalk from 'chalk'
import { generateCommandHelp, EXIT_CODES } from './registry'

type Shell = 'bash' | 'zsh' | 'fish'

/**
 * All Happy CLI commands for completion
 * This is intentionally duplicated from registry.ts to keep completion scripts minimal
 */
const COMMANDS = {
  auth: {
    subcommands: ['login', 'logout', 'status', 'help'],
    options: { login: ['--force'], status: ['--show-token'] }
  },
  codex: {
    subcommands: [],
    options: { '': ['--started-by'] }
  },
  connect: {
    subcommands: ['codex', 'claude', 'gemini', 'help'],
    options: {}
  },
  notify: {
    subcommands: [],
    options: { '': ['-p', '-t', '-h', '--help'] }
  },
  daemon: {
    subcommands: ['start', 'stop', 'status', 'health', 'list', 'stop-session', 'logs', 'install', 'uninstall'],
    options: { status: ['--json'], health: ['--json'] }
  },
  doctor: {
    subcommands: ['clean'],
    options: {}
  },
  completion: {
    subcommands: ['bash', 'zsh', 'fish'],
    options: {}
  }
} as const

/**
 * Global options available on the main happy command
 */
const GLOBAL_OPTIONS = ['--yolo', '--resume', '--verbose', '--version', '--help', '-h']

/**
 * Generate bash completion script
 */
function generateBashCompletion(): string {
  const commands = Object.keys(COMMANDS)

  return `# Happy CLI bash completion
# Generated by: happy completion bash
#
# Installation:
#   happy completion bash > /etc/bash_completion.d/happy
# Or for user-only:
#   happy completion bash > ~/.local/share/bash-completion/completions/happy
#   source ~/.local/share/bash-completion/completions/happy

_happy_completions() {
    local cur prev words cword
    _init_completion -n = || return

    local commands="${commands.join(' ')}"
    local global_opts="${GLOBAL_OPTIONS.join(' ')}"

    # Handle subcommand completion
    if [[ \${cword} -eq 1 ]]; then
        # First argument: commands or global options
        COMPREPLY=( \$(compgen -W "\${commands} \${global_opts}" -- "\${cur}") )
        return
    fi

    local cmd="\${words[1]}"

    case "\${cmd}" in
        auth)
            if [[ \${cword} -eq 2 ]]; then
                COMPREPLY=( \$(compgen -W "${COMMANDS.auth.subcommands.join(' ')}" -- "\${cur}") )
            elif [[ \${cword} -ge 3 ]]; then
                case "\${words[2]}" in
                    login)
                        COMPREPLY=( \$(compgen -W "--force" -- "\${cur}") )
                        ;;
                    status)
                        COMPREPLY=( \$(compgen -W "--show-token" -- "\${cur}") )
                        ;;
                esac
            fi
            ;;
        connect)
            if [[ \${cword} -eq 2 ]]; then
                COMPREPLY=( \$(compgen -W "${COMMANDS.connect.subcommands.join(' ')}" -- "\${cur}") )
            fi
            ;;
        daemon)
            if [[ \${cword} -eq 2 ]]; then
                COMPREPLY=( \$(compgen -W "${COMMANDS.daemon.subcommands.join(' ')}" -- "\${cur}") )
            elif [[ \${cword} -ge 3 ]]; then
                case "\${words[2]}" in
                    status|health)
                        COMPREPLY=( \$(compgen -W "--json" -- "\${cur}") )
                        ;;
                esac
            fi
            ;;
        doctor)
            if [[ \${cword} -eq 2 ]]; then
                COMPREPLY=( \$(compgen -W "${COMMANDS.doctor.subcommands.join(' ')}" -- "\${cur}") )
            fi
            ;;
        completion)
            if [[ \${cword} -eq 2 ]]; then
                COMPREPLY=( \$(compgen -W "${COMMANDS.completion.subcommands.join(' ')}" -- "\${cur}") )
            fi
            ;;
        notify)
            COMPREPLY=( \$(compgen -W "-p -t -h --help" -- "\${cur}") )
            ;;
        codex)
            COMPREPLY=( \$(compgen -W "--started-by" -- "\${cur}") )
            ;;
    esac
}

complete -F _happy_completions happy
`
}

/**
 * Generate zsh completion script
 */
function generateZshCompletion(): string {
  return `#compdef happy
# Happy CLI zsh completion
# Generated by: happy completion zsh
#
# Installation:
#   mkdir -p ~/.zfunc
#   happy completion zsh > ~/.zfunc/_happy
#   # Add to ~/.zshrc before compinit:
#   fpath=(~/.zfunc \$fpath)

_happy() {
    local -a commands
    local -a global_opts

    commands=(
        'auth:Manage authentication'
        'codex:Start Codex mode'
        'connect:Connect AI vendor API keys'
        'notify:Send push notification'
        'daemon:Manage background service'
        'doctor:System diagnostics & troubleshooting'
        'completion:Generate shell completion scripts'
    )

    global_opts=(
        '--yolo[Bypass permissions]'
        '--resume[Resume a previous session]'
        '--verbose[Enable verbose output]'
        '--version[Show version information]'
        '(-h --help)'{-h,--help}'[Show help message]'
    )

    _arguments -C \\
        "1: :{_describe 'command' commands}" \\
        '*:: :->args' \\
        \${global_opts}

    case \$state in
        args)
            case \$words[1] in
                auth)
                    local -a auth_cmds
                    auth_cmds=(
                        'login:Authenticate with Happy'
                        'logout:Remove authentication and machine data'
                        'status:Show authentication status'
                        'help:Show help message'
                    )
                    _arguments -C \\
                        "1: :{_describe 'auth command' auth_cmds}" \\
                        '*:: :->auth_args'

                    case \$state in
                        auth_args)
                            case \$words[1] in
                                login)
                                    _arguments '--force[Clear credentials before re-auth]'
                                    ;;
                                status)
                                    _arguments '--show-token[Display the full auth token]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                connect)
                    local -a connect_cmds
                    connect_cmds=(
                        'codex:Store OpenAI API key'
                        'claude:Store Anthropic API key'
                        'gemini:Store Gemini API key'
                        'help:Show help message'
                    )
                    _describe 'connect command' connect_cmds
                    ;;
                daemon)
                    local -a daemon_cmds
                    daemon_cmds=(
                        'start:Start the daemon'
                        'stop:Stop the daemon'
                        'status:Show daemon status'
                        'health:Show daemon health metrics'
                        'list:List active sessions'
                        'stop-session:Stop a specific session'
                        'logs:Show path to latest log file'
                        'install:Install as system service'
                        'uninstall:Uninstall system service'
                    )
                    _arguments -C \\
                        "1: :{_describe 'daemon command' daemon_cmds}" \\
                        '*:: :->daemon_args'

                    case \$state in
                        daemon_args)
                            case \$words[1] in
                                status|health)
                                    _arguments '--json[Output in JSON format]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                doctor)
                    local -a doctor_cmds
                    doctor_cmds=(
                        'clean:Kill runaway processes'
                    )
                    _describe 'doctor command' doctor_cmds
                    ;;
                completion)
                    local -a shells
                    shells=(
                        'bash:Generate bash completion'
                        'zsh:Generate zsh completion'
                        'fish:Generate fish completion'
                    )
                    _describe 'shell' shells
                    ;;
                notify)
                    _arguments \\
                        '-p[Notification message]:message:' \\
                        '-t[Notification title]:title:' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
                codex)
                    _arguments '--started-by[Specify start mode]:mode:(daemon terminal)'
                    ;;
            esac
            ;;
    esac
}

_happy "\$@"
`
}

/**
 * Generate fish completion script
 */
function generateFishCompletion(): string {
  return `# Happy CLI fish completion
# Generated by: happy completion fish
#
# Installation:
#   happy completion fish > ~/.config/fish/completions/happy.fish

# Disable file completion by default
complete -c happy -f

# Main commands
complete -c happy -n "__fish_use_subcommand" -a "auth" -d "Manage authentication"
complete -c happy -n "__fish_use_subcommand" -a "codex" -d "Start Codex mode"
complete -c happy -n "__fish_use_subcommand" -a "connect" -d "Connect AI vendor API keys"
complete -c happy -n "__fish_use_subcommand" -a "notify" -d "Send push notification"
complete -c happy -n "__fish_use_subcommand" -a "daemon" -d "Manage background service"
complete -c happy -n "__fish_use_subcommand" -a "doctor" -d "System diagnostics"
complete -c happy -n "__fish_use_subcommand" -a "completion" -d "Generate shell completions"

# Global options
complete -c happy -n "__fish_use_subcommand" -l yolo -d "Bypass permissions"
complete -c happy -n "__fish_use_subcommand" -l resume -d "Resume a previous session"
complete -c happy -n "__fish_use_subcommand" -l verbose -d "Enable verbose output"
complete -c happy -n "__fish_use_subcommand" -l version -d "Show version"
complete -c happy -n "__fish_use_subcommand" -s h -l help -d "Show help"

# auth subcommands
complete -c happy -n "__fish_seen_subcommand_from auth" -a "login" -d "Authenticate with Happy"
complete -c happy -n "__fish_seen_subcommand_from auth" -a "logout" -d "Remove authentication"
complete -c happy -n "__fish_seen_subcommand_from auth" -a "status" -d "Show authentication status"
complete -c happy -n "__fish_seen_subcommand_from auth" -a "help" -d "Show help message"
complete -c happy -n "__fish_seen_subcommand_from auth; and __fish_seen_subcommand_from login" -l force -d "Clear credentials first"
complete -c happy -n "__fish_seen_subcommand_from auth; and __fish_seen_subcommand_from status" -l show-token -d "Display full token"

# connect subcommands
complete -c happy -n "__fish_seen_subcommand_from connect" -a "codex" -d "Store OpenAI API key"
complete -c happy -n "__fish_seen_subcommand_from connect" -a "claude" -d "Store Anthropic API key"
complete -c happy -n "__fish_seen_subcommand_from connect" -a "gemini" -d "Store Gemini API key"
complete -c happy -n "__fish_seen_subcommand_from connect" -a "help" -d "Show help message"

# daemon subcommands
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "start" -d "Start the daemon"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "stop" -d "Stop the daemon"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "status" -d "Show daemon status"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "health" -d "Show health metrics"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "list" -d "List active sessions"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "stop-session" -d "Stop a session"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "logs" -d "Show log file path"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "install" -d "Install as service"
complete -c happy -n "__fish_seen_subcommand_from daemon" -a "uninstall" -d "Uninstall service"
complete -c happy -n "__fish_seen_subcommand_from daemon; and __fish_seen_subcommand_from status" -l json -d "JSON output"
complete -c happy -n "__fish_seen_subcommand_from daemon; and __fish_seen_subcommand_from health" -l json -d "JSON output"

# doctor subcommands
complete -c happy -n "__fish_seen_subcommand_from doctor" -a "clean" -d "Kill runaway processes"

# completion subcommands
complete -c happy -n "__fish_seen_subcommand_from completion" -a "bash" -d "Generate bash completion"
complete -c happy -n "__fish_seen_subcommand_from completion" -a "zsh" -d "Generate zsh completion"
complete -c happy -n "__fish_seen_subcommand_from completion" -a "fish" -d "Generate fish completion"

# notify options
complete -c happy -n "__fish_seen_subcommand_from notify" -s p -d "Notification message" -r
complete -c happy -n "__fish_seen_subcommand_from notify" -s t -d "Notification title" -r
complete -c happy -n "__fish_seen_subcommand_from notify" -s h -l help -d "Show help"

# codex options
complete -c happy -n "__fish_seen_subcommand_from codex" -l started-by -d "Specify start mode" -ra "daemon terminal"
`
}

/**
 * Handle the completion command
 *
 * @param args - Command arguments (expected: ['bash' | 'zsh' | 'fish'])
 */
export async function handleCompletionCommand(args: string[]): Promise<void> {
  const shell = args[0] as Shell | undefined

  if (!shell || args.includes('--help') || args.includes('-h')) {
    const help = generateCommandHelp('completion')
    if (help) {
      console.log(help)
    }
    return
  }

  switch (shell) {
    case 'bash':
      console.log(generateBashCompletion())
      break
    case 'zsh':
      console.log(generateZshCompletion())
      break
    case 'fish':
      console.log(generateFishCompletion())
      break
    default:
      console.error(chalk.red(`Unknown shell: ${shell}`))
      console.log(chalk.gray('Supported shells: bash, zsh, fish'))
      console.log(chalk.gray('Run "happy completion --help" for usage.'))
      process.exit(EXIT_CODES.GENERAL_ERROR.code)
  }
}
